from langgraph.graph import END, StateGraph, START

from langchain.pydantic_v1 import BaseModel, Field

from langchain_core.messages import BaseMessage


from typing import List

from typing import Dict

from langchain_openai import ChatOpenAI, OpenAIEmbeddings

from langgraph.checkpoint.memory import MemorySaver

from langchain_core.messages import  AIMessage

from langchain_core.prompts import PromptTemplate


openai_api_key="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"

open_ai_small_path = "C:/Users/HP/Desktop/streamlit_trial/deneme_files/chroma/"
embed_model = OpenAIEmbeddings(openai_api_key="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", model="text-embedding-3-small")   

parent_config = {"configurable": {"thread_id": "4"}}

from langgraph.graph.message import add_messages
from typing import Annotated, Literal, Sequence, TypedDict


class State(TypedDict):
    words:List[str]
    character_limit:int
    specified_criterias: str
    undesired_words:str
    desired_words:str
    product_name:str
    title_character_count_rew: str
    desired_words_rew: str
    undesired_words_rew: str
    specified_criterias_rew: str
    title_produced:str
    review_list:Annotated[Sequence[AIMessage], add_messages]

def title_generator(state):
    class listing(BaseModel):
        """Route a user query to the most relevant graph."""
        title: str = Field(
            ...,
            description="""You will provide me with a product title that will be used for Amazon within the specified character limits and in accordance with the specified criteria.""",
        )


    llm = ChatOpenAI(model="gpt-4o", temperature=0, openai_api_key=openai_api_key)

    structured_llm_router = llm.with_structured_output(listing)


    product_name = state["product_name"]
    character_limit = state["character_limit"]
    specified_criterias = state["specified_criterias"]
    desired_words = state["desired_words"]
    undesired_words = state["undesired_words"]
    chracter_lower_limit = character_limit - 10

    words_to_promt = ", ".join(state["words"])
    prev_titles = "\n".join([a.content for a in listing_graph.get_state(config=parent_config)[0]["title_list"]])
    if "title_character_count_rew" in state.keys():
        if state["title_character_count_rew"]:
            print(state["review_list"])
            error_revs = "\n".join([a.content for a in state["review_list"]])

            parent_route_prompt = PromptTemplate.from_template(
            """
            Your task is to reproduce the title that was previously generated by AI but stuck on some criteria, in a way that fits the criteria.
    
            It would be nice if you could use as many of the words here as you can to create meaningful sentences when creating listings:
    
            {words_to_promt}
    
            product_name: {product_name}
    
            chrachter_limit: {chracter_lower_limit} to {character_limit} 
    
            specified criterias: {specified_criterias}
    
            words that are specifically requested to be mentioned: {desired_words}
    
            words that should not be used specifically: {undesired_words}
    
            -----------
    
            previously generated titles with errors:
    
            {error_revs}
    
            
            Also, create a title that is not too similar to the titles that have been created before.
    
            previously generated titles:
    
            {prev_titles}
    
            """
            )


            parent_route_prompt = parent_route_prompt.format(product_name=product_name, character_limit=character_limit,
                                                            specified_criterias=specified_criterias,
                                                            desired_words=desired_words, undesired_words=undesired_words,
                                                            chracter_lower_limit=chracter_lower_limit,
                                                            error_revs=error_revs, prev_titles=prev_titles, words_to_promt=words_to_promt)

            output = structured_llm_router.invoke(parent_route_prompt)


    else:
        parent_route_prompt = PromptTemplate.from_template(
        """
        Your task is to create a title for the specified product within the specified character limit.   

        If there are words that you specifically want to pass, be careful to pass those words. If there are words that you specifically want to leave out, be careful not to pass them either.
        
        It would be nice if you could use as many of the words here as you can to create meaningful sentences when creating listings:

        {words_to_promt}
        
        product_name: {product_name}

        chrachter_limit: {chracter_lower_limit} to {character_limit} 

        specified criterias: {specified_criterias}

        words that are specifically requested to be mentioned: {desired_words}

        words that should not be used specifically: {undesired_words}

        Also, create a title that is not too similar to the titles that have been created before.

        previously generated titles:

        {prev_titles}

        """
        )


        parent_route_prompt = parent_route_prompt.format(product_name=product_name, character_limit=character_limit, 
                                                        specified_criterias=specified_criterias,
                                                        desired_words=desired_words, undesired_words=undesired_words, 
                                                        chracter_lower_limit=chracter_lower_limit, words_to_promt=words_to_promt,
                                                        prev_titles=prev_titles)
        
        output = structured_llm_router.invoke(parent_route_prompt)

    state["title_produced"] = output.title
    print("title generation:  ", output.title)

    return {**state}

def title_review(state):
    class title_review(BaseModel):
        """Review title of AI model"""
        title_character_count_rew: str = Field(
            ...,
            description="""Whether the initial character length and the generated title match""",
        )
        desired_words_rew: str = Field(
            ...,
            description="""Are the specifically requested words used in the title?""",
        )

        undesired_words_rew: str = Field(
            ...,
            description="""Are there any particularly undesirable words in the title?""",
        )
        specified_criterias_rew: str = Field(
            ...,
            description="""Have the specifically stated criteria been met?""",
        )

    llm = ChatOpenAI(model="gpt-4o", temperature=0, openai_api_key=openai_api_key)

    structured_llm_router = llm.with_structured_output(title_review)

    
    parent_route_prompt = PromptTemplate.from_template(
    """
    Your job is to check if the previously generated AI title meets the criteria given. If it does not, you need to indicate the inappropriate parts.

    product_name: {product_name}

    chrachter_limit: {chracter_lower_limit} to {character_limit}

    specified criterias: {specified_criterias}

    words that are specifically requested to be mentioned: {desired_words}

    words that should not be used specifically: {undesired_words}
    --------------------------------------------
    
    Title produced: {title_produced}

    """)

    product_name = state["product_name"]
    character_limit = state["character_limit"]
    specified_criterias = state["specified_criterias"]
    desired_words = state["desired_words"]
    undesired_words = state["undesired_words"]
    title_produced = state["title_produced"]
    chracter_lower_limit = character_limit - 10




    parent_route_prompt = parent_route_prompt.format(product_name=product_name, character_limit=character_limit, 
                                                     specified_criterias=specified_criterias,
                                                     desired_words=desired_words, undesired_words=undesired_words,
                                                     title_produced=title_produced, chracter_lower_limit=chracter_lower_limit)
    
    output = structured_llm_router.invoke(parent_route_prompt)

    state["title_character_count_rew"] = output.title_character_count_rew
    state["desired_words_rew"] = output.desired_words_rew
    state["undesired_words_rew"] = output.undesired_words_rew
    state["specified_criterias_rew"] = output.specified_criterias_rew
    rev = "title: " +  title_produced  + "\n title review: " + "title_character_count_rew: " + output.title_character_count_rew + \
        "desired_words_rew: " + output.desired_words_rew + "undesired_words_rew: " + output.undesired_words_rew + "specified_criterias_rew: " \
            + output.specified_criterias_rew 
    state["review_list"]  = [rev]


    return {**state}

def decision_maker(state):
    class decision(BaseModel):
        """Review title of AI model"""
        Is_the_title_successful: Literal["reproduce", "successful"]  = Field(
            ...,
            description="""You will decide whether the title produced is successful or not.""",
        )
    product_name = state["product_name"]
    character_limit = state["character_limit"]
    specified_criterias = state["specified_criterias"]
    desired_words = state["desired_words"]
    undesired_words = state["undesired_words"]
    title_produced = state["title_produced"]
    chracter_lower_limit = character_limit - 10

    title_character_count_rew = state["title_character_count_rew"]
    desired_words_rew = state["desired_words_rew"]
    undesired_words_rew = state["undesired_words_rew"]
    specified_criterias_rew = state["specified_criterias_rew"]


    parent_route_prompt = PromptTemplate.from_template(
    """
    Your task is to either generate a new title from scratch, based on the title previously generated by the AI ​​and the evaluation of this title by another AI, or to terminate the graph if the title is successful.

    Title produced: {title_produced}

    chrachter_limit: {chracter_lower_limit} to {character_limit}, chrachter limit review: {title_character_count_rew}

    specified criterias: {specified_criterias}, specified criterias review: {specified_criterias_rew}

    words that are specifically requested to be mentioned: {desired_words}, desired words review: {desired_words_rew}

    words that should not be used specifically: {undesired_words}, undesired_words_review: {undesired_words_rew}
    --------------------------------------------
    

    """)


    parent_route_prompt = parent_route_prompt.format(product_name=product_name, character_limit=character_limit, 
                                                     specified_criterias=specified_criterias,
                                                     desired_words=desired_words, undesired_words=undesired_words,
                                                     title_produced=title_produced,chracter_lower_limit=chracter_lower_limit,
                                                     title_character_count_rew=title_character_count_rew,
                                                     specified_criterias_rew=specified_criterias_rew, desired_words_rew=desired_words_rew,
                                                     undesired_words_rew=undesired_words_rew)
    
    llm = ChatOpenAI(model="gpt-4o", temperature=0, openai_api_key=openai_api_key)

    structured_llm_router = llm.with_structured_output(decision)


    output = structured_llm_router.invoke(parent_route_prompt)
    print("wwwwwwwww: decision:  ", output.Is_the_title_successful)
    return output.Is_the_title_successful


def ss(state):
    print("ssssssssss")
    print(state)
    return {**state}

subgraph = StateGraph(State)
subgraph.add_node("title_generator",title_generator)
subgraph.add_node("title_review",title_review)
# subgraph.add_node("decision_maker",decision_maker)
subgraph.add_node("ss",ss)


subgraph.add_edge(START, "title_generator")
subgraph.add_edge("title_generator", "title_review")
# subgraph.add_edge("title_review", "decision_maker")

subgraph.add_conditional_edges(
    "title_review",
    decision_maker,
    {"reproduce":"title_generator" ,"successful":"ss"}
)
subgraph.add_edge("ss", END)
memory = MemorySaver()

graph = subgraph.compile(checkpointer=memory)





def_desc = """
        Bullet points
        SOFT & COMFORTABLE FOR DOG CUDDLES - Crafted for canine cuddles, this shirt is every dog mom's dream for a cozy, snug feel on walks or lounging at home.
        TAILORED FOR PET PARENTS - Sized just right, our tees are the go-to for dog lovers, offering a fit that's as perfect as the bond with their furry friend.
        DURABLE PAW & PUP GRAPHICS - Resilient and playful graphics that stay put wash after wash, just like the paw prints on your heart.
        THE ULTIMATE DOG LOVER'S GIFT - The perfect surprise for any occasion, this tee celebrates the joy of being a pet parent in a fun and stylish way.
        LIGHT & BREATHABLE FOR DAILY ROMPS - Whether you're playing fetch or out for a walk, this lightweight tee keeps you cool and comfortable all day long.

        Description:
        Unveil the heartwarming connection between a dog mom and her furry companion with the Sky Apparel "All I Need Is This Dog" Shirt. This piece is more than just a garment; it's a celebration of the joyful and sometimes humorous life shared with dogs. Designed for comfort and adorned with playful graphics that resonate with every dog lover, this shirt is the perfect attire for daily walks, cuddle sessions, or simply showcasing dog mom pride. Whether it's a gift for yourself or a fellow dog lover, this tee encapsulates the essence of pet parenthood in a fun, stylish, and casual way, making every day a little brighter with a reminder of the pup love that fills your life
        """
def get_prompt(title, old_desc):
    promt = f"""You will help me prepare bullet points and descriptions for the sweatshirt product on Amazon.

        I'll give you a sample draft with bullet points and a description.

        I will also show you the good and bad reviews about such products. While preparing the bullet point and description, you can mention that the good features here are also in our product or the bad features here are not in our product.

        Finally, I will give the title of the product and some important keywords. You can use these to create meaningful sentences in bullet points or in the description.

        Stay away from exaggerated language!!!

        I need 5 bullet points and A product description that will not exceed 800 characters.

        GOOD FEATURES
        Soft : The softness of the material is appreciated. Sample sentence: Soft: This sweatshirt was the best purchase. It’s truly so soft
        Cute : Customers find the sweatshirt cute. Sample sentence: Cute: The design is really cute and stylish.
        Comfortable : Comfort is a significant positive point. Sample sentence: Comfortable: I love how comfortable this sweatshirt is. Perfect for lounging around.
        Perfect : Some customers describe it as the perfect sweatshirt. Sample sentence: Perfect: It fits perfectly and looks exactly like the picture.
        Great : The overall great quality is mentioned. Sample sentence: Great: The quality is great, especially for the price.
        Love : Many customers express love for the sweatshirt. Sample sentence: Love: I absolutely love this sweatshirt! It's my new favorite.
        Fit : The fit of the sweatshirt is appreciated by some. Sample sentence: Fit: The fit is just right, not too tight or too loose.
        Quality : The quality of the material is praised. Sample sentence: Quality: I was pleasantly surprised by the quality of the material.

        BAD FEATURES
        Thin : The thinness of the fabric is a common complaint. Sample sentence: Thin: The material is very thin, almost see-through.
        Small : Issues with the sizing being too small. Sample sentence: Small: Runs very small. I recommend ordering a size up.
        Disappointed : General disappointment expressed. Sample sentence: Disappointed: I was really disappointed with the quality.
        Shrink : Complaints about the sweatshirt shrinking. Sample sentence: Shrink: It shrank significantly after the first wash.
        Peel : Issues with the material peeling. Sample sentence: Peel: The fabric started to peel after just one wash.
        Short : The length being too short for some customers. Sample sentence: Short: The length is too short for my liking.
        Smaller : Running smaller than expected. Sample sentence: Smaller: The sweatshirt is much smaller than expected.
        Wrist : Specific complaints about the wrist area. Sample sentence: Wrist: The wrist area is too tight and uncomfortable.
        Oversized : Some find the sizing too oversized. Sample sentence: Oversized: It’s much more oversized than I expected.


        Template Bullet Points and Product Description You can look at the bullet points and descriptions here, but try not to make them too similar:

        {old_desc}

        Product Title:
        {title}

        """

    return promt

def description_generator(title, desc):


        llm = ChatOpenAI(model="gpt-4o", temperature=0, openai_api_key=openai_api_key)
        promt = get_prompt(title, desc)

        response = llm.invoke(promt)

        res = response.content

        if "Product Description" not in res:
                prod_des = "Description"
        else:
                prod_des = "Product Description"

        if "Bullet Points" not in res:
                bul_point = "Bullet points"
        else:
                bul_point = "Bullet Points"

        bullets = [i.replace("**","").replace("- ","",1).replace("\\","") for i in res[res.index(bul_point):res.index(prod_des)].split("\n") if len(i)> 50]
        desc = [i.replace("**","").replace("- ","",1).replace("\\","")  for i in res[res.index(prod_des):].split("\n") if len(i) > 50]

        fin = bullets + desc
        # state["description"] = fin
        return fin


config = {"configurable": {"thread_id": "2"},"recursion_limit": 10}
from langgraph.errors import GraphRecursionError

class ParentState(TypedDict):
    words:List[str]
    listing_count:int
    character_limit:int
    specified_criterias: str
    undesired_words:str
    desired_words:str
    product_name:str
    title_character_count_rew: str
    desired_words_rew: str
    undesired_words_rew: str
    specified_criterias_rew: str
    title_produced:str
    review_list:Annotated[Sequence[AIMessage], add_messages]
    title_list:Annotated[Sequence[AIMessage], add_messages]
    desc_list:Annotated[Sequence[AIMessage], add_messages]
    listings:Annotated[Dict[str, List[BaseMessage]], lambda x, y: y if y is not None else x]

def parent_title_node(state):
    config = {"configurable": {"thread_id": "2"},"recursion_limit": 10}
    try:
        graph.invoke({**state}, config=config)
    except GraphRecursionError:
        print("Recursion Error")

    title = graph.get_state(config=config).values["title_produced"]
    state["title_list"] = title

    return {**state}

def parent_desc_node(state):
    title = state["title_list"][-1]
    print(state["desc_list"])
    if not len(state["desc_list"]) == 0:
        desc = state["desc_list"][-1]

    else:
        desc  =def_desc
    fin = description_generator(title, desc)
    state["desc_list"] = fin
    return {**state}

def control(state):
    if len(state["title_list"]) == state["listing_count"]:
        return "break"
    else:
        return "continue"

def dummy(state):
    return {**state}

parent_graph = StateGraph(ParentState)
parent_graph.add_node("title_generation", parent_title_node)
parent_graph.add_node("description_generation", parent_desc_node)
# parent_graph.add_node("control", control)
parent_graph.add_node("dummy", dummy)


parent_graph.add_edge(START, "title_generation")
parent_graph.add_edge("title_generation", "description_generation")

# parent_graph.add_edge("description_generation", "control")

parent_graph.add_conditional_edges(
    "description_generation",
    control,
    {"continue":"title_generation" ,"break":"dummy"}
)
parent_graph.add_edge("dummy", END)

memory = MemorySaver()

listing_graph = parent_graph.compile(checkpointer=memory)
